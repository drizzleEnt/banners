## Сервис баннеров
Сервис, который может показывать разный контент пользователям в зависимости от их принадлежности к какой-либо группе. Данный контент предоставляется с помощью баннеров.
## Общие вводные
**Баннер** — это документ, описывающий какой-либо элемент пользовательского интерфейса. Технически баннер представляет собой  JSON-документ неопределенной структуры. 
**Тег** — это сущность для обозначения группы пользователей; представляет собой число (ID тега). 
**Фича** — это домен или функциональность; представляет собой число (ID фичи).  
1. Один баннер может быть связан только с одной фичей и несколькими тегами
2. При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно
3. Фича и тег однозначно определяют баннер

## Условия

## Дополнительные задания:
Эти задания не являются обязательными, но выполнение всех или части из них даст вам преимущество перед другими кандидатами. 
1. Адаптировать систему для значительного увеличения количества тегов и фичей, при котором допускается увеличение времени исполнения по редко запрашиваемым тегам и фичам
2. Провести нагрузочное тестирование полученного решения и приложить результаты тестирования к решению
3. Иногда получается так, что необходимо вернуться к одной из трех предыдущих версий баннера в связи с найденной ошибкой в логике, тексте и т.д.  Измените API таким образом, чтобы можно было просмотреть существующие версии баннера и выбрать подходящую версию
4. Добавить метод удаления баннеров по фиче или тегу, время ответа которого не должно превышать 100 мс, независимо от количества баннеров.  В связи с небольшим временем ответа метода, рекомендуется ознакомиться с механизмом выполнения отложенных действий 
5. Реализовать интеграционное или E2E-тестирование для остальных сценариев
6. Описать конфигурацию линтера

## Стек
- **Язык сервиса:** Go. 
- **База данных:** PostgreSQL. 
- Для **деплоя зависимостей и самого сервиса** используется Docker и Docker Compose.
## Команды для запуска
В проекте присутствует docker-compose и Makefile. Для запуска приложения в docker conteiner достаточно написать команду make docker-build-and-run. После сборки приложения и запуска контейнера сервис будет доступен по адресу 0.0.0.0:8080/
1. 0.0.0.0:8080/user_banner/ (Get)
    Необходимо указать в запросе feature_id=<feature_id>&tag_id=<tag_id>. Пример запроса 0.0.0.0:8080/user_banner/?feature_id=8&tag_id=3. Так же в header должен быть указан token вида "token: <token>", пользовательский токен: user_token, токен администратора: admin_token.
    В ответ сервис вернет статус код, ошибку, если будет обнаружена, полученные из базы данных баннеры, если будут совпадения, и для пользователей если найденные баннеры будут иметь активный статус. JSON ответа вида: 
    {
    "title": "some_title",
    "text": "some_Text",
    "url": "some_url"
    }
# Остальные запросы могут быть исполнены лишь при указании администратоского токена
1. 0.0.0.0:8080/banner/ (GET) Получение всех баннеров c фильтрацией по фиче и/или тегу 
    В header должен быть указан token вида "token: <token>", токен администратора: admin_token.
    В запросе должен быть указан или тег или фича или оба. Так же можно указать лимит и оффсет. 
    Итоговый запрос вида 0.0.0.0:8080//banner/?feature_id={feature_id}&tag_id={tag_id}&limit={limit}&offset={offset}
    В ответ сервис вернет статус код, ошибку, если будет обнаружена, полученные из базы данных баннеры, если будут совпадения, и для пользователей если найденные баннеры будут иметь активный статус. JSON ответа имеет вид массива баннеров:
    [
    {
        "ID": id,
        "title": "some_title",
        "text": "some_Text",
        "url": "some_url"
        "is_active": is_active,
        "IsValid": false,
        "feature_id": feature_id,
        "tag_id": [tag_ids],
        "CreatedAt": "created_at",
        "UpdatedAt": {
            "Time": "updated_at",
            "Valid": is_valid
        }
    }
    ]
2. 0.0.0.0:8080/banner/ (POST) Создание нового баннера
    В header должен быть указан token вида "token: <token>", токен администратора: admin_token.
    В теле запроса должен быть заполнен JSON вида:
        {
            "title": "some",
            "text": "some text",
            "url": "https://www.directout-of-the-box.biz/networks/virtual/generate",
            "is_active": true,
            "feature_id": 6,
            "tag_id":[56,7,58]
        }
    В ответ сервис вернет статус код, ошибку, если будет обнаружена, id созданного банера

3.  0.0.0.0:8080/banner/{:id} (PATCH) Обновление содержимого баннера
    В header должен быть указан token вида "token: <token>", токен администратора: admin_token.
    В строке запроса должен быть указан id баннера из базы данных.
    В теле запроса должен быть заполнен JSON с названием полей и новыми значениями, которые необхадимо вставить.

    В ответ сервис вернет статус код, ошибку, если будет обнаружена.

4. 0.0.0.0:8080/banner/{:id} (DELETE) Удаление баннера по идентификатору
    В header должен быть указан token вида "token: <token>", токен администратора: admin_token.
    В строке запроса должен быть указан id баннера из базы данных.

    В ответ сервис вернет статус код, ошибку, если будет обнаружена.

# Проблемы с которыми столкнулся

1. Запуск прилоения в контейнере. Изначально не проходили запросы на сервер, пока не разобрался с правильным указанием хост и порт в .env файле для HTTP Server.
2. Запрос на обновление баннера. Для реализации логики при которой можно было бы указать лишь одно поле и id, в силу ограниченности по времени было принято решение использовать два запроса в базу данных для получения старых значиний и замены их новыми.
3. Отсутствие опыта в создании интеграционных тестах.

# Итог
    Задание мне показалось достаточно интересным, мне пришлось испытать свои силы в реализации методов, которых ранее не делал. Так же углубился в контейнеризацию, а именно работу с Dockerfile и docker-compose. 